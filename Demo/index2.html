<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPG 走路示範</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: "Noto Sans TC", sans-serif;
            background: url('image/green.png') center center / cover no-repeat;
        }

        #stage {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .hex-layer {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.6);
            opacity: 0.08;
            clip-path: polygon(
                50% 0%,
                100% 25%,
                100% 75%,
                50% 100%,
                0% 75%,
                0% 25%
            );
            animation: hex-flicker 2.8s ease-in-out infinite;
            pointer-events: auto;
            cursor: pointer;
            z-index: 2;
        }

        .hex-layer.top-left {
            top: 100px;
            left: 100px;
            animation-delay: 0.4s;
        }

        .hex-layer.bottom-right {
            right: 100px;
            bottom: 100px;
            animation-delay: 1.3s;
        }

        #character-container {
            position: absolute;
            bottom: 18%;
            left: 0;
            width: 110px;
            height: 110px;
            z-index: 10;
            transition: left 0.05s linear;
        }

        #character-img {
            width: 100%;
            height: auto;
            display: block;
            filter: drop-shadow(0 10px 5px rgba(0,0,0,0.35));
            transition: transform 0.1s ease;
        }

        #series-toggle {
            position: fixed;
            right: 20px;
            bottom: 20px;
            z-index: 20;
            padding: 10px 16px;
            border-radius: 999px;
            border: none;
            background: rgba(0, 0, 0, 0.75);
            color: #fff;
            font-size: 0.95rem;
            cursor: pointer;
            box-shadow: 0 6px 12px rgba(0,0,0,0.25);
        }

        #series-toggle:hover {
            background: rgba(0, 0, 0, 0.9);
        }

        #hex-overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease;
            z-index: 30;
        }

        #hex-overlay.is-active {
            opacity: 1;
            visibility: visible;
        }

        .hex-overlay-content {
            width: min(720px, 90vw);
            aspect-ratio: 16 / 9;
            position: relative;
        }

        .hex-overlay-content svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        .hex-overlay-point,
        .hex-overlay-triangle {
            cursor: pointer;
            pointer-events: all;
        }

        #marquee-overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.35);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease;
            z-index: 40;
        }

        #marquee-overlay.is-active {
            opacity: 1;
            visibility: visible;
        }

        #marquee-text {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            font-size: 20px;
            line-height: 1.6;
            text-align: center;
            color: #b3b3b3;
            cursor: pointer;
            user-select: none;
            white-space: pre-wrap;
        }

        .marquee-line {
            color: #b3b3b3;
            transition: color 0.2s ease;
        }

        #marquee-text .marquee-line.is-center {
            color: #b9d9ff;
            text-shadow: 0 0 8px rgba(130, 180, 255, 0.6);
        }

        @keyframes hex-flicker {
            0%,
            100% {
                opacity: 0.08;
            }
            45% {
                opacity: 0.4;
            }
            60% {
                opacity: 0.16;
            }
            80% {
                opacity: 0.32;
            }
        }
    </style>
</head>
<body>
    <div id="stage">
        <div class="hex-layer top-left"></div>
        <div class="hex-layer bottom-right"></div>
        <div id="character-container">
            <img id="character-img" src="" alt="Character">
        </div>
    </div>

    <div id="hex-overlay" aria-hidden="true">
        <div class="hex-overlay-content">
            <svg viewBox="0 0 720 405" aria-hidden="true">
                <defs>
                    <mask id="overlay-cutout">
                        <rect width="720" height="405" fill="white"></rect>
                        <path d="M 315 165 L 315 240 Q 315 265 340 255 L 410 220 Q 435 202.5 410 185 L 340 150 Q 315 140 315 165 Z" fill="black"></path>
                    </mask>
                </defs>
    
                <rect width="720" height="405" fill="#000" mask="url(#overlay-cutout)"></rect>
    
                <path class="hex-overlay-triangle" d="M 315 165 L 315 240 Q 315 265 340 255 L 410 220 Q 435 202.5 410 185 L 340 150 Q 315 140 315 165 Z" fill="transparent"></path>
            </svg>
        </div>
    </div>

    <div id="marquee-overlay" aria-hidden="true">
        <div id="marquee-text" role="button" aria-label="跑馬燈文字"></div>
    </div>

    <button id="series-toggle" type="button">切換到可愛系列</button>

    <script>
        const seriesOptions = [
            { label: '一般系列', suffix: '' },
            { label: '可愛系列', suffix: '_cute' }
        ];

        let currentSeriesIndex = 1;
        let svgFrames = buildFrames(seriesOptions[currentSeriesIndex].suffix);

        function buildFrames(suffix) {
            return [
                `image/Walk1${suffix}.svg`,
                `image/Walk2${suffix}.svg`,
                `image/Walk3${suffix}.svg`,
                `image/Walk4${suffix}.svg`,
                `image/Walk5${suffix}.svg`,
                `image/Walk6${suffix}.svg`
            ];
        }

        const charImgElement = document.getElementById('character-img');
        const characterContainer = document.getElementById('character-container');
        const seriesToggleButton = document.getElementById('series-toggle');
        const hexLayers = document.querySelectorAll('.hex-layer');
        const hexOverlay = document.getElementById('hex-overlay');
        const overlayTriangle = hexOverlay.querySelector('.hex-overlay-triangle');
        const marqueeOverlay = document.getElementById('marquee-overlay');
        const marqueeText = document.getElementById('marquee-text');

        const marqueeState = {
            animationId: null,
            isActive: false,
            isPaused: false,
            currentOffset: 0,
            startOffset: 0,
            endOffset: 0,
            lineStep: 0,
            speed: 0,
            lastTimestamp: null,
            lastCenterIndex: -1
        };

        function openHexOverlay() {
            hexOverlay.classList.add('is-active');
            hexOverlay.setAttribute('aria-hidden', 'false');
        }

        function closeHexOverlay() {
            hexOverlay.classList.remove('is-active');
            hexOverlay.setAttribute('aria-hidden', 'true');
        }

        function openMarqueeOverlay() {
            marqueeOverlay.classList.add('is-active');
            marqueeOverlay.setAttribute('aria-hidden', 'false');
            marqueeState.isActive = true;
            marqueeState.isPaused = false;
            marqueeState.lastTimestamp = null;

            return fetch('content_1.txt')
                .then(response => response.text())
                .then(text => {
                    const lines = text.split(/\r?\n/);
                    marqueeText.innerHTML = '';
                    lines.forEach(line => {
                        const lineElement = document.createElement('div');
                        lineElement.className = 'marquee-line';
                        lineElement.textContent = line === '' ? ' ' : line;
                        marqueeText.appendChild(lineElement);
                    });

                    requestAnimationFrame(() => {
                        const lineElements = marqueeText.querySelectorAll('.marquee-line');
                        if (!lineElements.length) {
                            return;
                        }

                        // 直接使用容器的實際高度，不需手動累加計算
                        const containerHeight = marqueeText.offsetHeight;
                        const firstLine = lineElements[0];
                        const lastLine = lineElements[lineElements.length - 1];

                        // 1. 設定起始位置：讓「第一行」的中心點對齊螢幕正中間
                        // 公式：(容器半高) - (第一行的中心位置)
                        const firstLineCenter = firstLine.offsetTop + (firstLine.offsetHeight / 2);
                        marqueeState.startOffset = (containerHeight / 2) - firstLineCenter;

                        // 2. 設定結束位置：讓「最後一行」捲到螢幕正中間後停止 (或是你可以自訂要捲過頭)
                        const lastLineCenter = lastLine.offsetTop + (lastLine.offsetHeight / 2);
                        marqueeState.endOffset = (containerHeight / 2) - lastLineCenter;

                        // 3. 設定初始狀態
                        marqueeState.currentOffset = marqueeState.startOffset;
                
                        // 設定速度 (維持原本邏輯，用第一行高度當基準，或是你可以直接給定數值如 30)
                        marqueeState.speed = firstLine.offsetHeight / 1.1;
                        updateMarqueePosition();
                        updateMarqueeCenterLine();
                        startMarqueeScroll();
                    });
                })
                .catch(() => {
                    marqueeText.innerHTML = '<div class="marquee-line">無法載入內容</div>';
                });
        }

        function closeMarqueeOverlay() {
            marqueeOverlay.classList.remove('is-active');
            marqueeOverlay.setAttribute('aria-hidden', 'true');
            marqueeState.isActive = false;
            marqueeState.isPaused = false;
            marqueeState.lastTimestamp = null;
            if (marqueeState.animationId) {
                cancelAnimationFrame(marqueeState.animationId);
                marqueeState.animationId = null;
            }
            marqueeState.lastCenterIndex = -1;
            marqueeText.innerHTML = '';
        }

        function updateMarqueePosition() {
            marqueeText.style.transform = `translate(-50%, -50%) translateY(${marqueeState.currentOffset}px)`;
        }

        function updateMarqueeCenterLine() {
            // 取得所有文字行
            const lineElements = marqueeText.querySelectorAll('.marquee-line');
            if (!lineElements.length) return;

            // 計算目前捲動容器的「視覺中心點」在容器內部的 Y 座標
            // 原理：容器本身被 translate(-50%, -50%) 置中，所以容器中心點 (offsetHeight / 2) 初始是對齊螢幕中心的
            // 當加上 translateY(currentOffset) 後，實際對齊螢幕中心的點會往上移，所以要減去 currentOffset
            const containerCenterY = (marqueeText.offsetHeight / 2) - marqueeState.currentOffset;

            let closestIndex = -1;
            let minDistance = Infinity;

            // 遍歷每一行，找出中心點離 containerCenterY 最近的那一行
            lineElements.forEach((el, index) => {
                const elCenter = el.offsetTop + (el.offsetHeight / 2);
                const dist = Math.abs(elCenter - containerCenterY);

                if (dist < minDistance) {
                    minDistance = dist;
                    closestIndex = index;
                }
            });

            // 如果找到的行跟上一次不一樣，就更新樣式
            if (closestIndex !== -1 && marqueeState.lastCenterIndex !== closestIndex) {
                if (marqueeState.lastCenterIndex !== -1 && lineElements[marqueeState.lastCenterIndex]) {
                    lineElements[marqueeState.lastCenterIndex].classList.remove('is-center');
                }
                lineElements[closestIndex].classList.add('is-center');
                marqueeState.lastCenterIndex = closestIndex;
            }
        }

        function startMarqueeScroll() {
            if (marqueeState.animationId) {
                cancelAnimationFrame(marqueeState.animationId);
            }

            const step = (timestamp) => {
                if (!marqueeState.isActive) {
                    marqueeState.animationId = null;
                    return;
                }

                if (!marqueeState.lastTimestamp) {
                    marqueeState.lastTimestamp = timestamp;
                }

                const deltaSeconds = (timestamp - marqueeState.lastTimestamp) / 1000;
                marqueeState.lastTimestamp = timestamp;

                if (!marqueeState.isPaused) {
                    marqueeState.currentOffset -= marqueeState.speed * deltaSeconds;
                    if (marqueeState.currentOffset <= marqueeState.endOffset) {
                        marqueeState.currentOffset = marqueeState.endOffset;
                    }
                    updateMarqueePosition();
                    updateMarqueeCenterLine();
                }

                if (marqueeState.currentOffset <= marqueeState.endOffset) {
                    marqueeState.animationId = null;
                    return;
                }

                marqueeState.animationId = requestAnimationFrame(step);
            };

            marqueeState.animationId = requestAnimationFrame(step);
        }

        function toggleMarqueePause() {
            marqueeState.isPaused = !marqueeState.isPaused;
            if (!marqueeState.isPaused) {
                marqueeState.lastTimestamp = null;
                startMarqueeScroll();
            }
        }

        function handleOverlayTriangleClick(event) {
            event.stopPropagation();
            closeHexOverlay();
            openMarqueeOverlay();
        }

        function preloadFrames(frames) {
            frames.forEach(src => {
                const img = new Image();
                img.src = src;
            });
        }

        preloadFrames(svgFrames);

        let currentFrameIndex = 0;
        let animationInterval = null;
        let isWalking = false;

        function playNextFrame() {
            currentFrameIndex = (currentFrameIndex + 1) % svgFrames.length;
            charImgElement.src = svgFrames[currentFrameIndex];
        }

        function startWalking() {
            if (isWalking) return;
            isWalking = true;
            animationInterval = setInterval(playNextFrame, 100);
        }

        function stopWalking() {
            if (!isWalking) return;
            isWalking = false;
            clearInterval(animationInterval);
            animationInterval = null;
            currentFrameIndex = 0;
            charImgElement.src = svgFrames[0];
        }

        function setSeries(index) {
            currentSeriesIndex = index;
            svgFrames = buildFrames(seriesOptions[currentSeriesIndex].suffix);
            preloadFrames(svgFrames);
            currentFrameIndex = 0;
            charImgElement.src = svgFrames[0];
            seriesToggleButton.textContent = `切換到${seriesOptions[(currentSeriesIndex + 1) % seriesOptions.length].label}`;
        }

        seriesToggleButton.addEventListener('click', () => {
            const nextIndex = (currentSeriesIndex + 1) % seriesOptions.length;
            setSeries(nextIndex);
        });

        setSeries(currentSeriesIndex);

        hexLayers.forEach(layer => {
            layer.addEventListener('click', () => {
                openHexOverlay();
            });
        });

        hexOverlay.addEventListener('click', (event) => {
            if (event.target === hexOverlay) {
                closeHexOverlay();
            }
        });

        overlayTriangle.addEventListener('click', handleOverlayTriangleClick);

        marqueeOverlay.addEventListener('click', (event) => {
            if (!marqueeText.contains(event.target)) {
                closeMarqueeOverlay();
            }
        });

        marqueeText.addEventListener('click', (event) => {
            event.stopPropagation();
            toggleMarqueePause();
        });

        let currentX = 0;
        let maxX = 0;
        let stopScrollingTimer = null;

        function updateBounds() {
            const containerWidth = characterContainer.offsetWidth;
            maxX = Math.max(0, window.innerWidth - containerWidth);
            currentX = Math.min(Math.max(currentX, 0), maxX);
            characterContainer.style.left = `${currentX}px`;
        }

        function moveCharacter(deltaY) {
            const direction = deltaY < 0 ? 1 : -1;
            const step = Math.min(60, Math.abs(deltaY)) * 0.7;
            currentX += direction * step;
            currentX = Math.min(Math.max(currentX, 0), maxX);
            characterContainer.style.left = `${currentX}px`;
            charImgElement.style.transform = direction === -1 ? 'scaleX(-1)' : 'scaleX(1)';
        }

        window.addEventListener('wheel', (event) => {
            event.preventDefault();
            moveCharacter(event.deltaY);
            startWalking();

            if (stopScrollingTimer !== null) {
                clearTimeout(stopScrollingTimer);
            }

            stopScrollingTimer = setTimeout(() => {
                stopWalking();
            }, 150);
        }, { passive: false });

        window.addEventListener('resize', updateBounds);

        window.addEventListener('load', () => {
            currentX = (window.innerWidth - characterContainer.offsetWidth) / 2;
            updateBounds();
        });
    </script>
</body>
</html>
