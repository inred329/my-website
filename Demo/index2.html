<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPG 走路示範</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: "Noto Sans TC", sans-serif;
            background: url('image/green.png') center center / cover no-repeat;
        }

        #stage {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .hex-layer {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.6);
            opacity: 0.08;
            clip-path: polygon(
                50% 0%,
                100% 25%,
                100% 75%,
                50% 100%,
                0% 75%,
                0% 25%
            );
            animation: hex-flicker 2.8s ease-in-out infinite;
            pointer-events: auto;
            cursor: pointer;
            z-index: 2;
        }

        .hex-layer.top-left {
            top: 100px;
            left: 100px;
            animation-delay: 0.4s;
        }

        .hex-layer.bottom-right {
            right: 100px;
            bottom: 100px;
            animation-delay: 1.3s;
        }

        #character-container {
            position: absolute;
            bottom: 18%;
            left: 0;
            width: 110px;
            height: 110px;
            z-index: 10;
            transition: left 0.05s linear;
        }

        #character-img {
            width: 100%;
            height: auto;
            display: block;
            filter: drop-shadow(0 10px 5px rgba(0,0,0,0.35));
            transition: transform 0.1s ease;
        }

        #series-toggle {
            position: fixed;
            right: 20px;
            bottom: 20px;
            z-index: 20;
            padding: 10px 16px;
            border-radius: 999px;
            border: none;
            background: rgba(0, 0, 0, 0.75);
            color: #fff;
            font-size: 0.95rem;
            cursor: pointer;
            box-shadow: 0 6px 12px rgba(0,0,0,0.25);
        }

        #series-toggle:hover {
            background: rgba(0, 0, 0, 0.9);
        }

        #hex-overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease;
            z-index: 30;
        }

        #hex-overlay.is-active {
            opacity: 1;
            visibility: visible;
        }

        .hex-overlay-content {
            width: min(720px, 90vw);
            aspect-ratio: 16 / 9;
            position: relative;
        }

        .hex-overlay-content svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        .hex-overlay-point,
        .hex-overlay-triangle {
            cursor: pointer;
            pointer-events: all;
        }

        @keyframes hex-flicker {
            0%,
            100% {
                opacity: 0.08;
            }
            45% {
                opacity: 0.4;
            }
            60% {
                opacity: 0.16;
            }
            80% {
                opacity: 0.32;
            }
        }
    </style>
</head>
<body>
    <div id="stage">
        <div class="hex-layer top-left"></div>
        <div class="hex-layer bottom-right"></div>
        <div id="character-container">
            <img id="character-img" src="" alt="Character">
        </div>
    </div>

    <div id="hex-overlay" aria-hidden="true">
        <div class="hex-overlay-content">
            <svg viewBox="0 0 720 405" aria-hidden="true">
                <defs>
                    <mask id="overlay-cutout">
                        <rect width="720" height="405" fill="white"></rect>
                        <path d="M 315 165 L 315 240 Q 315 265 340 255 L 410 220 Q 435 202.5 410 185 L 340 150 Q 315 140 315 165 Z" fill="black"></path>
                    </mask>
                </defs>
    
                <rect width="720" height="405" fill="#000" mask="url(#overlay-cutout)"></rect>
    
                <path class="hex-overlay-triangle" d="M 315 165 L 315 240 Q 315 265 340 255 L 410 220 Q 435 202.5 410 185 L 340 150 Q 315 140 315 165 Z" fill="transparent"></path>
    
                <g class="hex-overlay-points" fill="transparent">
                    <circle class="hex-overlay-point" cx="360" cy="65" r="16"></circle>
                    <circle class="hex-overlay-point" cx="590" cy="200" r="16"></circle>
                    <circle class="hex-overlay-point" cx="360" cy="340" r="16"></circle>
                    <circle class="hex-overlay-point" cx="130" cy="200" r="16"></circle>
                </g>
            </svg>
        </div>
    </div>

    <button id="series-toggle" type="button">切換到可愛系列</button>

    <script>
        const seriesOptions = [
            { label: '一般系列', suffix: '' },
            { label: '可愛系列', suffix: '_cute' }
        ];

        let currentSeriesIndex = 1;
        let svgFrames = buildFrames(seriesOptions[currentSeriesIndex].suffix);

        function buildFrames(suffix) {
            return [
                `image/Walk1${suffix}.svg`,
                `image/Walk2${suffix}.svg`,
                `image/Walk3${suffix}.svg`,
                `image/Walk4${suffix}.svg`,
                `image/Walk5${suffix}.svg`,
                `image/Walk6${suffix}.svg`
            ];
        }

        const charImgElement = document.getElementById('character-img');
        const characterContainer = document.getElementById('character-container');
        const seriesToggleButton = document.getElementById('series-toggle');
        const hexLayers = document.querySelectorAll('.hex-layer');
        const hexOverlay = document.getElementById('hex-overlay');
        const overlayTriangle = hexOverlay.querySelector('.hex-overlay-triangle');
        const overlayPoints = hexOverlay.querySelectorAll('.hex-overlay-point');

        function openHexOverlay() {
            hexOverlay.classList.add('is-active');
            hexOverlay.setAttribute('aria-hidden', 'false');
        }

        function closeHexOverlay() {
            hexOverlay.classList.remove('is-active');
            hexOverlay.setAttribute('aria-hidden', 'true');
        }

        function handleOverlayPointClick(event) {
            event.stopPropagation();
        }

        function handleOverlayTriangleClick(event) {
            event.stopPropagation();
        }

        function preloadFrames(frames) {
            frames.forEach(src => {
                const img = new Image();
                img.src = src;
            });
        }

        preloadFrames(svgFrames);

        let currentFrameIndex = 0;
        let animationInterval = null;
        let isWalking = false;

        function playNextFrame() {
            currentFrameIndex = (currentFrameIndex + 1) % svgFrames.length;
            charImgElement.src = svgFrames[currentFrameIndex];
        }

        function startWalking() {
            if (isWalking) return;
            isWalking = true;
            animationInterval = setInterval(playNextFrame, 100);
        }

        function stopWalking() {
            if (!isWalking) return;
            isWalking = false;
            clearInterval(animationInterval);
            animationInterval = null;
            currentFrameIndex = 0;
            charImgElement.src = svgFrames[0];
        }

        function setSeries(index) {
            currentSeriesIndex = index;
            svgFrames = buildFrames(seriesOptions[currentSeriesIndex].suffix);
            preloadFrames(svgFrames);
            currentFrameIndex = 0;
            charImgElement.src = svgFrames[0];
            seriesToggleButton.textContent = `切換到${seriesOptions[(currentSeriesIndex + 1) % seriesOptions.length].label}`;
        }

        seriesToggleButton.addEventListener('click', () => {
            const nextIndex = (currentSeriesIndex + 1) % seriesOptions.length;
            setSeries(nextIndex);
        });

        setSeries(currentSeriesIndex);

        hexLayers.forEach(layer => {
            layer.addEventListener('click', () => {
                openHexOverlay();
            });
        });

        hexOverlay.addEventListener('click', (event) => {
            if (event.target === hexOverlay) {
                closeHexOverlay();
            }
        });

        overlayPoints.forEach(point => {
            point.addEventListener('click', handleOverlayPointClick);
        });

        overlayTriangle.addEventListener('click', handleOverlayTriangleClick);

        let currentX = 0;
        let maxX = 0;
        let stopScrollingTimer = null;

        function updateBounds() {
            const containerWidth = characterContainer.offsetWidth;
            maxX = Math.max(0, window.innerWidth - containerWidth);
            currentX = Math.min(Math.max(currentX, 0), maxX);
            characterContainer.style.left = `${currentX}px`;
        }

        function moveCharacter(deltaY) {
            const direction = deltaY < 0 ? 1 : -1;
            const step = Math.min(60, Math.abs(deltaY)) * 0.7;
            currentX += direction * step;
            currentX = Math.min(Math.max(currentX, 0), maxX);
            characterContainer.style.left = `${currentX}px`;
            charImgElement.style.transform = direction === -1 ? 'scaleX(-1)' : 'scaleX(1)';
        }

        window.addEventListener('wheel', (event) => {
            event.preventDefault();
            moveCharacter(event.deltaY);
            startWalking();

            if (stopScrollingTimer !== null) {
                clearTimeout(stopScrollingTimer);
            }

            stopScrollingTimer = setTimeout(() => {
                stopWalking();
            }, 150);
        }, { passive: false });

        window.addEventListener('resize', updateBounds);

        window.addEventListener('load', () => {
            currentX = (window.innerWidth - characterContainer.offsetWidth) / 2;
            updateBounds();
        });
    </script>
</body>
</html>
